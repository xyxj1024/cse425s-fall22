<html><style>table tr:nth-child(even) {background: #FFF}table tr:nth-child(odd) {background: #EEF}</style><body><h2>Xingjian Xuanyuan</h2><h2>total: 23.0/26 = 0.885</h2><h2>with 3 free misses: 23.0/23 = 1.0</h2><table><col width="10%"><col width="10%"><col width="10%"><col width="10%"><col width="30%"><col width="30%"><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94528">Functional Static 1a (S&Q Prep)</a></strong></td></tr><tr valign="top"><td class="colA">Aug30 13:22</td><td class="colA">on time</td><td class="colA">1.0</td><td class="colBC">True</td><td class="colBC">First, Prof. Grossman recommends using Emacs for ML scripting. I did install the SML/NJ compiler, but I decided to use VS Code on my Mac instead.

ML is quite different a programming language from those I have learned before. I do not have to explicitly specify the type of a variable as I declare it because it will be type-checked at compile time.

The code samples provided by Prof. Grossman present heavy use of recursion programming technique, which gives programs a simple and clean look, very helpful for illustrating new concepts.</td><td class="colBC">In what situations should we use the let statement rather than just define a new function?

Besides, I'm not sure if anyone are using VS Code on Mac. I installed the extension "Standard ML Environment". The use "filename.sml" trick works well. However, when I tried to run selected code, an error saying "SML process died" kept popping out. What value should I set to sml-environment-interpreter-path attribute on my settings.json file?

Thank you!</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94529">Functional Static 1b (S&Q Prep)</a></strong></td></tr><tr valign="top"><td class="colA">Aug30 13:17</td><td class="colA">on time</td><td class="colA">1.0</td><td class="colBC">True</td><td class="colBC">There is no NULL pointer in ML as in C. The option type provides a solution.

The immutability of ML's basic data types is secure, compared with other languages in certain cases.

Syntax, semantics, idioms, libraries and tools are the five issues that programmers should care about while using a programming language. We are mainly focused on semantics and idioms in this course.</td><td class="colBC">What are other use cases for option, except handling potential undefined values?</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94530">Functional Static 2a (S&Q Prep)</a></strong></td></tr><tr valign="top"><td class="colA">Sep06 14:44</td><td class="colA">on time</td><td class="colA">1.0</td><td class="colBC">True</td><td class="colBC">This section of videos introduce compound datatypes and constructions in Standard ML that group homogeneous and heterogeneous data types. Their syntax may be summarized as "each-of", "one-of", or "self-reference". As a programmer, we should choose the most concise expression while checking for non-redundancy and exhausitiveness.</td><td class="colBC">As watching the video, I just found that self type checking could be tedious if considerable compound type programming is involved. My question is: What is the best programming style for SML that can balance correctness, conciseness and readability?</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94531">Functional Static 2b (S&Q Prep)</a></strong></td></tr><tr valign="top"><td class="colA">Sep10 22:14</td><td class="colA">on time</td><td class="colA">1.0</td><td class="colBC">True</td><td class="colBC">These segments introduce us a more complete picture of pattern matching in SML programming, which may guide us to write codes that are more readable and concise.</td><td class="colBC">The differences between types and datatypes in SML are interesting to me. Can we say that a datatype introduces a pattern to construct a new type and a type is more like a C struct?</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94532">Language and Thought; Functional Static 2c (S&Q Prep)</a></strong></td></tr><tr valign="top"><td class="colA">Sep11 04:22</td><td class="colA">on time</td><td class="colA">1.0</td><td class="colBC">True</td><td class="colBC">Tail-recursive function calls save memory spaces by reusing the same stack frame, and sometimes run faster than traditional recursive function calls. However, there are data structures, like trees, that can be better implemented using traditional recursion.</td><td class="colBC">Which programming languages do not support tail-recursive optimization?</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94533">Functional Static 3a (S&Q Prep)</a></strong></td></tr><tr valign="top"><td class="colA">Sep13 21:12</td><td class="colA">on time</td><td class="colA">1.0</td><td class="colBC">True</td><td class="colBC">A function can be the argument, or return value, of another function.

Function bindings are not expressions. This feature determines what can be passed in as function arguments.

There are variable bindings and function bindings that can be used interchangeably. However, not all the cases represent good programming style.</td><td class="colBC">In these segments, we have seen a lot of examples showing nested function declarations, functions that can be evaluated inside a cartin higher-order function. My question is, does this programming style introduce extra difficulties for self-typechecking and debugging?</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94534">Story of Your Life; Functional Static 3b (S&Q Prep)</a></strong></td></tr><tr valign="top"><td class="colA">Sep15 03:11</td><td class="colA">on time</td><td class="colA">1.0</td><td class="colBC">True</td><td class="colBC">For most of the times, programming languages choose lexical scope over dynamical scope, which is an important decision when combining function calls with each other.

A closure is a convenient way to access a function from a function inside. The use of closure and currying illustrate the relationships between different functions (e.g., public or private) with respect to their scopes.

It is not always more efficient using currying, which depends on the interaction between the programming language and its compiler.</td><td class="colBC">The code examples from Prof. Grossman's video lectures give me the impression that functions can be shared among functions just like objects. This is great because we are able to end up with clean and concise function interfaces, as well as an appropriate global namespace. Is this a unique feature of functional programming?</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94535">Functional Static 3c; Course Motivation (S&Q Prep)</a></strong></td></tr><tr valign="top"><td class="colA">Sep16 02:26</td><td class="colA">on time</td><td class="colA">1.0</td><td class="colBC">True</td><td class="colBC">These segments deals with some bigger pictures. Different programming languages may differ in their semantics and/or idioms, but they are all used to design precise interface. As programmers, we should make good use of the features associated with the language we choose.

Mutability provides control while introduces trouble. Techniques learned in this class can be helpful dealing with mutability issues.</td><td class="colBC">In the Java example for implementing closures, Dan says that letting null represent the empty set/list may cause trouble. Is it because we cannot call a method on null?</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94536">Functional Static 4a (S&Q Prep)</a></strong></td></tr><tr valign="top"><td class="colA">Sep21 01:46</td><td class="colA">on time</td><td class="colA">1.0</td><td class="colBC">True</td><td class="colBC">After viewing the lecture videos, I have a sense that a deeper knowledge of type-checking may help me better understand error messages.

I think it is truly helpful for us to have a basic understanding, if not thorough, about how programming languages do type-checking, expression evaluation, etc. The value restriction approach taken by SML to type-checking combinations of polymorphism and mutation might limit the expressive power of the language. But I suppose it is necessary, and rigorous, indeed. I actually don't like the mutual recursion technique at first glance since it makes programs less readable. Perhaps I need more sample code to appreciate its usefulness.</td><td class="colBC">Is it possible that SML can be used for proofs in mathematics and physics? Are there any softwares doing related stuffs? In what languages they are written?</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94537">Functional Static 4b (S&Q Prep)</a></strong></td></tr><tr valign="top"><td class="colA">Sep22 05:06</td><td class="colA">on time</td><td class="colA">1.0</td><td class="colBC">True</td><td class="colBC">These segments dig deeper into software architecture, which is quite different from previous lectures.

While designing ADTs, or other types of modules, we should distinguish between (external) specifications and (internal) invariants. A module can not only hide certain bindings/functions from clients through the definition of signature, but also values/types that may violate invariants. These techniques produce clean interfaces among objects.

A signature's type binding for a function must be more specific than the type binding for the function in the module.</td><td class="colBC">1. Is it better to write a structure before writing its corresponding signature, or not? (Given that objects in a signature are always less generic than, if not equivalent to, in the structure it specifies.)

2. Is there a formal definition of equivalence of structures (not functions) in SML (or other programming languages)?

3. Can we nest a structure inside a signature, or vice versa? What are the use cases?</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94538">1984; Functors (S&Q Prep)</a></strong></td></tr><tr valign="top"><td>&nbsp;</td><td>none</td><td>0.0</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94539">Sorted Dictionary (S&Q Prep)</a></strong></td></tr><tr valign="top"><td class="colA">Oct16 06:13</td><td class="colA">on time</td><td class="colA">1.0</td><td class="colBC">True</td><td class="colBC">Drink some chocolate milk and take a nap.</td><td class="colBC">2</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94540">The Lambda Calculus; Spreadsheet to Dictionaries (S&Q Prep)</a></strong></td></tr><tr valign="top"><td class="colA">Oct17 20:42</td><td class="colA">on time</td><td class="colA">1.0</td><td class="colBC">True</td><td class="colBC">The Lambda Calculus is the idea behind functional programming. A function in Lambda Calculus has no internal states. Computation, at the most abstract level, symbolizes the process of expression evaluation, which does not necessarily need a type system. Recursion is generalized by Y Combinator, which evaluates a function of itself.

The video from Fullstack Academy shows how boolean expressions are encoded using Lambda Calculus. Intersting stuff.

Kestrel combinator:

func kestrel<A, B>(a : A) -> B -> A {

    return { _ in a }

}

Starling combinator:

func starling<A, B, C>(f : (A -> B -> C)) -> (A -> B) -> A -> C {

    return { g in { x in f(x)(g(x)) } }

}

Identity combinator:

func idiot<A>(x : A) -> A {

    return x

}

which is actually

starling(kestrel)(kestrel(a))(a)</td><td class="colBC">The Lambda Calculus is just something that has great explanatory power but not quite useful in the real world, isn't it? Similar idea I can think of: Karl Marx's labor theory of value.</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94541">Functional Dynamic 1a (S&Q Prep)</a></strong></td></tr><tr valign="top"><td class="colA">Oct24 00:26</td><td class="colA">on time</td><td class="colA">1.0</td><td class="colBC">True</td><td class="colBC">These video lectures introduce semantics of Racket, a descendant of Scheme. What impressed me the most is the usage of parenthesis in Racket, which actually helps distinguish literal types, identifiers, and procedures (evaluated lambda expressions).</td><td class="colBC">What does "subjective parenthesis-bashing" mean?</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94542">Functional Dynamic 1b (S&Q Prep)</a></strong></td></tr><tr valign="top"><td class="colA">Oct25 16:29</td><td class="colA">on time</td><td class="colA">1.0</td><td class="colBC">True</td><td class="colBC">If one can handle macros smoothlly, he can definitely write them into functions!</td><td class="colBC">Knowing when and how expressions are evaluated is one of the most important things in programming. It is the starting point for us to enjoy the flexibility of programming idioms and ensure correctness at the same time. I think this is the lesson I learned from the video lectures.

Macros are used to add syntatic sugars to our programs.</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94543">Functional Dynamic 2a (S&Q Prep)</a></strong></td></tr><tr valign="top"><td class="colA">Oct31 22:30</td><td class="colA">late (forgiven)</td><td class="colA">1.0</td><td class="colBC">True</td><td class="colBC">We can write programs without using structs (the "list" approach). However, struct support in a programming language (the "struct" approach) along with certain accessor functions can be really helpful (better style and more concise).</td><td class="colBC">Sorry I'm late</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94544">Functional Dynamic 2b (S&Q Prep)</a></strong></td></tr><tr valign="top"><td class="colA">Nov01 01:41</td><td class="colA">on time</td><td class="colA">1.0</td><td class="colBC">True</td><td class="colBC">If we would like to implement programming language (PL) B in PL A, we can just skip parsing and write the abstract syntax tree directly in PL A.

Legal ASTs are trees that the interpreter must handle. The interpreter always returns a value, which is an expression that evaluates to itself.

Evaluations take place in environments.

(define (eval-under-env e env) (cond ...)) 

(struct closure (env fun) #:transparent)</td><td class="colBC">I have been reading the book "The Definition of Standard ML". Will that be helpful for the MUPL assignment?</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94545">Functional Dynamic 3a (S&Q Prep)</a></strong></td></tr><tr valign="top"><td class="colA">Nov06 00:12</td><td class="colA">on time</td><td class="colA">1.0</td><td class="colBC">True</td><td class="colBC">Start revisiting Professor Grossman's video.</td><td class="colBC">Racket does not have a static typing system as ML, which provides some flexibility when writing functions. Alternatively seen by many, Racket exploits a "monolithic" type and uses structs to create new types.

Soundness of a type system (false nagatives are prevented)

Completeness of a type system (false positives are prevented)

Modern languages typically have sound but not complete type systems. It is impossible to implement a static type checker that given any program in certain language (a) always terminates, (b) is sound, and (c) is complete.</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94546">Functional Dynamic 3b (S&Q Prep)</a></strong></td></tr><tr valign="top"><td class="colA">Nov06 00:24</td><td class="colA">on time</td><td class="colA">1.0</td><td class="colBC">True</td><td class="colBC">Thank you, Professor Cosgrove, for your clarification on C's buffer overflow problem. With freedom comes responsibility.

The two sides of both static and dynamic typing should really be scrutinized within the context of what we want our programs to do.

Dynamic checking in the code truly makes our program look ugly and difficult to read.</td><td class="colBC">Why may eval be useful?</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94547">OOP Dynamic 1a (S&Q Prep)</a></strong></td></tr><tr valign="top"><td class="colA">Nov06 17:48</td><td class="colA">on time</td><td class="colA">1.0</td><td class="colBC">True</td><td class="colBC">Classes, objects (instances of classes/values of instance variables), values (the results from evaluating expressions), methods (messaging between objects), states (access control of objects), expressions (method calls, conditionals), visibility, wide mutability, dynamic definitions

Everything is an object. All objects have a nil? method.</td><td class="colBC">For Ruby installation, I tried all possible ways documented in this website: https://mac.install.guide/ruby/index.html, none of them works on my machine, which is wierd.

So far at this stage of learning Ruby, I just found that there are a lot of variable sharing taking place in a Ruby program. Does Ruby as a class-based PL normally use memory more efficiently than a functional PL?</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94548">OOP Dynamic 1b (S&Q Prep)</a></strong></td></tr><tr valign="top"><td class="colA">Nov11 22:07</td><td class="colA">on time</td><td class="colA">1.0</td><td class="colBC">True</td><td class="colBC">Arrays are so flexible in Ruby programs. I don't know how to describe its features in short paragraphs.

Blocks in Ruby, to me, resemble a kind of dynamic function body along with certain (name, value) pair(s) as its environment.

Instances of the Proc class can be viewed as real closures in Ruby.

The built-in support for hashes and ranges can also be seen in scripting languages such as Python and R.

 </td><td class="colBC">I need to program more in Ruby before I provide a serious question.</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94549">OOP Dynamic 1c (S&Q Prep)</a></strong></td></tr><tr valign="top"><td class="colA">Nov11 22:16</td><td class="colA">on time</td><td class="colA">1.0</td><td class="colBC">True</td><td class="colBC">A lot of stuffs describing what is a true OOP language.</td><td class="colBC">I have little experience in OOP. I'm reading the book "Inside the C++ Object Model", in which the author discusses how dynamic (and static) dispatch is implemented.</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94550">OOP Dynamic 2a (S&Q Prep)</a></strong></td></tr><tr valign="top"><td class="colA">Dec17 02:16</td><td class="colA">late (forgiven)</td><td class="colA">1.0</td><td class="colBC">True</td><td class="colBC">"The Matrix" is too old a film for me.

You take the blue pill, the story ends, you wake up in the morning and believe whatever you want to believe. You take the red pill, you stay in Wonderland, and I show you how deep the rabbit hole goes.

OOP: break programs down into classes that give behavior to some kind of data. Functional programming and object-oriented programming often do the same thing in exact opposite way (the matrix example).

General principle: if you know you want new operations, use FP; if you know you want new variants, use OOP.

Double dispatch (add_values v): tell v by calling different methods on v, passing self.

Multiple dispatch (multimethods): allow multiple methods with same name; indicate which ones take instances of which classes; use dynamic dispatch on arguments in addition to receiver to pick when method is called.</td><td class="colBC">Does the presence of double dispatch generates design burdens for compilers?</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94551">OOP Dynamic 2b (S&Q Prep)</a></strong></td></tr><tr valign="top"><td class="colA">Dec17 02:29</td><td class="colA">late (forgiven)</td><td class="colA">1.0</td><td class="colBC">True</td><td class="colBC">Different OOPs have different inheritance rules. For multiple inheritance like in C++, the class hierarchy is no longer a tree as in the case of single inheritance.

Ruby's mixin is an alternative to multiple inheritance, which is just a collection of methods. Including a mixin makes its methods part of the class. Sometimes, it creates odd styles.

Interface is a type used in statically-typed OOPs like Java. Each class is also a type.</td><td class="colBC">Flexibility, extensibility, code reuseaility are all we have to care about when choosing a PL for certain software project.  Does the popularity of Java and C++ indicate that mixins used in Ruby is not a great idea?</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94552">OOP Dynamic 3; The Computer Revolution Hasn't Happened Yet; Kingdom of Nouns; OOP Static 2: Interfaces, Classes, Inheritance, Final, Override (S&Q Prep)</a></strong></td></tr><tr valign="top"><td>&nbsp;</td><td>none</td><td>0.0</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td colspan="6"><strong><a href="https://wustl.instructure.com/courses/46551/quizzes/94553">Mostly Wrong History; OOP Static 3: Producer Extends Consumer Super; Teach Yourself Programming in Ten Years (S&Q Prep)</a></strong></td></tr><tr valign="top"><td>&nbsp;</td><td>none</td><td>0.0</td><td>&nbsp;</td><td>&nbsp;</td></tr></table></body></html>